#![allow(unused)]
    // std にはコレクションという非常に有益なデータ構造を含んでいる
    // コレクションは複数の値を含むことができる
    // 組み込みの配列とタプル型とは違いコレクションのデータはヒープに確保されていて
    // データ量はコンパイル時にわかる必要はなく伸縮可能である
    // 各コレクションには異なる能力とコストが存在し様々な場面においてどれを使うべきかの判断力は軽々とともに育んでいきます
    // ここでは頻繁に使用される3つのコレクションについて紹介する
    //    ベクタ型 : 可変長(伸縮可能)な値を並べて保持できる。
    //    文字列 : 文字のコレクション。以前 String型について触れたがさらに詳しく掘り下げる。
    //    ハッシュマップ : 値を特定のキーと紐付けさせることが出来るより一般的なデータ構造。マップの特定の実装である。
    // 他のコレクションについて学ぶにはドキュメント参照
    // ベクタ型, 文字列, ハッシュマップの生成と更新方法や各々の特徴について学んでいきましょう

pub fn vector() {
  // ベクタで一連の値を保持する
    // 最初に見るコレクションは Vec<T> です
    // ベクタとも言いメモリ上に値を隣り合わせに並べる単独のデータ構造に2つ以上の値を保持させてくれる
    // ベクタには同じ型の値しか保持できない、要素のリストがある場合に有用
    // 例えばテキストファイルの各行やショッピングカートのアイテムの価格など

   // 新しいベクタを生成する
    // 新しい空のベクタを作るには Vec:new関数 を使う
    let v:Vec<i32> = Vec::new();
    // 値が何もないので型がわかるように注釈します

    // ベクタはジェネリクスを使用して実装されてる
    // 独自の型でジェネリクスを使用する方法についてはいずれ学ぶ
    // 今は std により提供されている Vec<T>型はどんな型でも保持でき、ベクタが特定の型を保持するとその型は <>内に指定されるということだけが分かれば良い
    // 一旦値を挿入したらコンパイラは保持させたい値の型を推論し続けられるので、このように型注釈をすることは滅多にない
    // 初期値のある Vec<T> を生成する方が一般的ですし Rust には vec!マクロも用意されている
    // vec!マクロは与えた値を保持する新しいベクタ型を生成します
	// 以下では 1, 2, 3 を持つ新しい Vec<i32> を生成している
	let v = vec![1, 2, 3];
	// 初期値として i32値を指定したのでコンパイラは v の型が Vec<i32> であると推論でき、型注釈は必要なくなる

   // ベクタを更新する
	// pushメソッドで要素を追加できます
	// もちろん値の改変には mut キーワードでの定義が必要です
	// 中に配置する数値は全てi32型であることをコンパイラをデータから推論するので Vec<i32> という注釈は必要なくなる
	let mut rgb = Vec::new();
	rgb.push(255);
	rgb.push(172);
	rgb.push(86);

   // ベクタをドロップすれば要素もドロップする
	// ベクタもスコープを抜ければ解放される
	{
		let test_vec = vec![1, 2, 3, 4];
		// ここでは test_vec は使用可能
	} // test_vec はここでスコープを抜けて解放される

	// ベクタがドロップされると中身もドロップされる。つまり保持されていた値が片付けられるということ
	// 一見単純なこと見えるかもしれないがベクタの要素への参照を導入した場合、少し複雑になるかもしれない

   // ベクタの要素を読む
	// 生成, 更新, 破棄 ができても使えなければ意味がない
	// 中身を読む方法は2種類在ります
	// 以下の例では分かりやすくする為に関数の返り値の型を注釈します
	// 以下は両メソッドがベクタの値に対して添字記法と getメソッドによりアクセスするところです
	let g:&i32 = &rgb[1]; // rgb[1] を g が借用する
	let g_ii:Option<&i32> = rgb.get(1); // 指数を引数として getメソッドに渡し Option<&T> を得る

	// ベクタに要素が含まれないインデックスの値を使用しようとした際プログラムの振る舞いを選択できる
	//let does_not_exist = &rgb[100]; // エラー
	// getメソッドがベクタ外の添え字を渡されると、パニックすることなくNoneを返します
	let offl = rgb.get(100);
	println!("{:?}", offl);//< None
	// ベクタの範囲外にアクセスする可能性がある場合にこのメソッドを使用することになる
	// そうしたらコードには Some(&element) か None を扱うロジックが存在することになる
	// 例えば人の入力した数値を input して添え字(インデックスとして)に入れることもできる
	// もし大きすぎる値を誤って入力してもプログラムが None値を得るので、それに応じて再度質問するようにできる

	// レかレ！
	let mut v_ii = vec![1, 2, 3, 4, 5]; 
	let first = &v_ii[0];
	v_ii.push(6);
	//println!("{:?}", first); // これはエラー
	// なぜ最初の要素への参照がベクタの終端への値追加に干渉されるのでしょう
	// 新規要素をベクタの終端に追加すると新しく追加する値分の領域を用意する必要がある(場合がある)
	// メモリの新規確保をして古い要素を新しいスペースにコピーすることになる
	// 移転されてしまっているので最初の要素を指す参照は解放されたメモリを指してしまう
	// エラーとなります

   // ベクタの値を走査する
	// ベクタの要素に順番にアクセスしたいなら添え字で1回に1要素にアクセスするのではなく全要素を走査することができます
	// 例えば以下だけで可能です
	let v_iii = vec![100, 32, 57];
	for i in &v_iii { println!("{}", i); }

	// 全要素に変更を加える目的で可変なベクタの各要素への可変な参照を走査することもできる
	// 以下では全要素に 50 を加算している
	let mut v_iv = vec![100, 32, 57];
	for i in &mut v_iv { *i += 50; }
	// 可変参照が参照している値を変更するには +=演算子を使用する前に参照外し演算子(*)を使用して i の値に辿り着かないといけない

   // Enumを使って複数の型を保持する
	// ベクタは同じ型の値しか保持できない
	// しかし enum の列挙子は同じ enum の型の元に定義される故ベクタに異なる型の要素を持たせたいなら enum を使用するとよい
	enum SpreadsheetCell {
		Int(i32),
		Float(f64),
		Text(String),
	}
	let row = vec![
		SpreadsheetCell::Int(3),
		SpreadsheetCell::Text(String::from("blue")),
		SpreadsheetCell::Float(10.12),
	];
	// rowベクタの中身は全て SpreadsheetCell型となる
	// 列挙子は違うため別の型を保持できる
}

pub fn string() {
 // 文字列でUTF-8でエンコードされたテキストを保持する
	// 生成, 更新, 読込など他のコレクションも持っている様なStringの処理について学ぶ
	// また String が他のコレクションと異なる点についても学ぶ

  // 文字列とは?
	// 文字列リテラルはプログラムのバイナリ出力に格納され、バイナリのその特定の位置を指すスライスなので文字列スライスになる
	// String型は std により提供されいるが 伸長可能, 可変, 所有権のある UTF-8エンコードされた文字列型です
	// Rust において「文字列」は どちらかではなく String と&str(文字列スライス)のことを指す
	// また std には他の文字列型も含まれている 例 OsString, OsStr, CString, CStr etc...
	// それらの名前が全て String か Str で終わっているのは、所有権ありと借用されたバージョンを指している

  // 新規文字列を生成する
	// Vec<T> で出来る処理の殆どが String でも使える
	// 空の文字列の生成は　String:new関数です
	let mut s = String::new();

	// to_stringメソッドで文字列の初期値を決める
	let data = "初期値!";
	let s_ii = data.to_string();
	
	// 文字列リテラルに直接連結も可能
	let s_iii = "初期値!".to_string();

	// String::from関数でも同じようなことが可能
	let s_iv = String::from("初期値!");

	// 文字列は色々な所で使うので多くの異なる API が用意されていて、たくさんの選択肢がある
	// 文字列は UTF-8エンコードされているので以下の文字は全て有効です
	let hello_ar = String::from("السلام عليكم");
	let hello_cs = String::from("Dobrý den");
	let hello_en = String::from("Hello");
	let hello_hb = String::from("שָׁלוֹם");
	let hello_ay = String::from("贵樣");
	let hello_hi = String::from("नमस्ते");
	let hello_ja = String::from("こんにちは");
	let hello_ko = String::from("안녕하세요");
	let hello_zh = String::from("你好");
	let hello_pt = String::from("Olá");
	let hello_ru = String::from("Здравствуйте");
	let hello_spa = String::from("Hola");

  // 文字列を更新する
	// String はサイズを伸ばすことができ Vec<T> の中身のように追加のデータをプッシュすれば中身も変化する
	// つまり String値を連結する +演算子や format!マクロを使用することができるということ

   // 1.push_str と push で文字列に追加する
	// push_strメソッドで文字列スライスを追記することで String を伸ばすことができる
	let mut yushu = String::from("优秀の");
	yushu.push_str("人材");
	println!("{}", yushu); //< 优秀の人材

    // なお、push_str関数に値を利用されても所有権は奪われません
	let mut tapioka = String::from("夕匕オ力に");
	let towshi = "投資ずゑ";
	tapioka.push_str(towshi); // towshi はまだ使える
	println!("{}", tapioka); //< 夕匕オ力に投資ずゑ
	
	// pushメソッドでは char型で追加できます
	let mut kisama = String::from("贵");
	kisama.push('樣'); // char型なのでシングルクォート
	println!("{}", kisama);
}