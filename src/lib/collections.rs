#![allow(unused)]
    // std にはコレクションという非常に有益なデータ構造を含んでいる
    // コレクションは複数の値を含むことができる
    // 組み込みの配列とタプル型とは違いコレクションのデータはヒープに確保されていて
    // データ量はコンパイル時にわかる必要はなく伸縮可能である
    // 各コレクションには異なる能力とコストが存在し様々な場面においてどれを使うべきかの判断力は軽々とともに育んでいきます
    // ここでは頻繁に使用される3つのコレクションについて紹介する
    //    ベクタ型 : 可変長(伸縮可能)な値を並べて保持できる。
    //    文字列 : 文字のコレクション。以前 String型について触れたがさらに詳しく掘り下げる。
    //    ハッシュマップ : 値を特定のキーと紐付けさせることが出来るより一般的なデータ構造。マップの特定の実装である。
    // 他のコレクションについて学ぶにはドキュメント参照
    // ベクタ型, 文字列, ハッシュマップの生成と更新方法や各々の特徴について学んでいきましょう

pub fn vector() {
  // ベクタで一連の値を保持する
    // 最初に見るコレクションは Vec<T> です
    // ベクタとも言いメモリ上に値を隣り合わせに並べる単独のデータ構造に2つ以上の値を保持させてくれる
    // ベクタには同じ型の値しか保持できない、要素のリストがある場合に有用
    // 例えばテキストファイルの各行やショッピングカートのアイテムの価格など

   // 新しいベクタを生成する
    // 新しい空のベクタを作るには Vec:new関数 を使う
    let v:Vec<i32> = Vec::new();
    // 値が何もないので型がわかるように注釈します

    // ベクタはジェネリクスを使用して実装されてる
    // 独自の型でジェネリクスを使用する方法についてはいずれ学ぶ
    // 今は std により提供されている Vec<T>型はどんな型でも保持でき、ベクタが特定の型を保持するとその型は <>内に指定されるということだけが分かれば良い
    // 一旦値を挿入したらコンパイラは保持させたい値の型を推論し続けられるので、このように型注釈をすることは滅多にない
    // 初期値のある Vec<T> を生成する方が一般的ですし Rust には vec!マクロも用意されている
    // vec!マクロは与えた値を保持する新しいベクタ型を生成します
	// 以下では 1, 2, 3 を持つ新しい Vec<i32> を生成している
	let v = vec![1, 2, 3];
	// 初期値として i32値を指定したのでコンパイラは v の型が Vec<i32> であると推論でき、型注釈は必要なくなる
}