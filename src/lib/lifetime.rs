#[allow(unused)]
pub fn lifetime() {
 // ライフタイムで参照を検証する
    // 参照や借用 において 一つ重要な詳細を説明していなかった
    // Rust において参照は 全てライフタイムを保持している
    // ライフタイムとは その参照が有効になるスコープのこと
    // 多くの場合、型が推論されるのと同じく ライフタイムも暗黙的に推論される
    // 複数の型が推論される場合は 型を注釈する必要があった
    // 同様に、参照のライフタイムが 幾つかの方法で関係する可能性がある場合は注釈しなければならない
    // コンパイラに ジェネリックライフタイム引数を使って関係を注釈して、
    // 実行時に「実際の参照が確かに有効であること」を保証しなければならない
    // ライフタイムの概念は、他のプログラミング言語の道具とは異端で 確実で Rust で1番際立つ機能となる

    // 今回でライフタイムの全体を解説することはない。ライフタイム記法が必要となる最も一般的な場合について学ぶ
    // ライフタイムの概念に馴染めるといいな( 'ω')

  // ライフタイムでダングリング参照を回避する
    // ライフタイムの主な目的は ダングリング参照を回避すること
    // ダングリング参照により プログラムが参照するつもりだったデータ以外のデータを参照してしまう
    // 以下は 外側のスコープと内側のスコープが含まれている

    // [NOTE] 値は生まれたスコープの終端に当たると死ぬ

    /*
    { //  外側のスコープ
        let r;
        { // 内側のスコープ
            let x = 5;
            r = &x;
        }
        println!("{}", r);
    }
    */

    //*note: 変数に初期値を与えずに宣言しているので 変数名は外側のスコープに存在する
    //       これは「Rust には null値が存在しない」ということと衝突してるように見えるかもしれない
    //       値を与える前に変数を使おうとすれば コンパイルエラーになる。これは Rust では null値は許可されないから

    // 外側のスコープで初期値なしの変数r を宣言して 内側のスコープで初期値が5の変数x を宣言している
    // 内側のスコープ内で r の値を xへの参照にしようとしている
    // それから内側のスコープが終わって r の値を出力しようとしている
    // r が参照している値が既にスコープを抜けるので このコードはコンパイルできない
    // つまり x の値を参照してるのに その x が既に drop(死亡) しててエラーってこと
    // こちらがエラーメッセージ

    /*
    error[E0597]: `x` does not live long enough // 訳: x の生存期間が短すぎる
      --> src/main.rs:X:X
       |
    X  |         r = &x;
       |              - borrow occurs here // 訳: 借用はここで起きている
    X  |     }
       |     ^ `x` dropped here while still borrowed // 訳: x は借用されている間にここでドロップ
    ...
    X  | }
       | - borrowed value needs to live until here // 訳: 借用された値はここまで生きる必要がある
    */

    // 変数x の「生存期間が短すぎる」の原因は、内側のスコープが終わった時点で x がスコープを抜けること
    // ですが r はまだ 外側のスコープに対して有効。スコープが大きいので「長生きする」と言う
    // Rust で このコードが動けたら r は x がスコープを抜けた時に解放されるメモリを参照していることになり、
    // r でやりたいことが正常に動作しない。ならばどの様にコンパイラは このコードが無効であると決定しているか。借用チェッカーを使用している

  // 借用精査機
	// Rustコンパイラには、スコープを比較して 全ての借用が有効であるかを決定する借用チェッカーがある
   	// 以下は 先ほどと同じコードに 変数のライフタイムを表示する注釈が付いている

    /*
    {
        let r;                // --------+- 'a   // a誕生🎊
        {                     //         |
            let x = 5;        // -+- 'b  |       // b誕生🎊
            r = &x;           //  |      |
        }                     // -+      |       // b死亡✞
        println!("{}", r);    //         |
    }                         // --------+       // a死亡✞
    */

    // ここで rのライフタイムは 'a 、xのライフタイムは 'b として注釈した
    // ご覧の通り 内側の 'b の方が 外側の 'a より遥かに短命
    // コンパイル時に コンパイラは2つのライフタイムのサイズを比較し、
    // r は 'a のライフタイムだが、'b のライフタイムのメモリを参照していると確認する
    // 'b は 'a よりも短命な故 プログラムは拒否される。参照の対象が参照の様には長生きしていない
    // 以下はコードを修正したので、ダングリング参照はなくなってエラーなくコンパイルできる

    {
        let x = 5;            // ---------+- 'b   // 'b誕生🎊
        let r = &x;           // --+- 'a  |       // 'a誕生🎊
        println!("r: {}", r); //   |      |
    }

    // ここで xのライフタイムは 'b であり、'a よりも大きい
    // つまり コンパイラは x が有効な間 r の参照も常に有効になると把握している故 rはxを参照できる
    // 今や 参照のライフタイムがどのくらいあって コンパイラが「ライフタイムを解析して参照が常に有効である」とを保証する仕組みがわかったので、
    // 関数の文脈でジェネリック引数と戻り値のライフタイムを探究する
}