#[allow(unused)]
pub fn lifetime() {
 // ライフタイムで参照を検証する
    // 参照や借用 において 一つ重要な詳細を説明していなかった
    // Rust において参照は 全てライフタイムを保持している
    // ライフタイムとは その参照が有効になるスコープのこと
    // 多くの場合、型が推論されるのと同じく ライフタイムも暗黙的に推論される
    // 複数の型が推論される場合は 型を注釈する必要があった
    // 同様に、参照のライフタイムが 幾つかの方法で関係する可能性がある場合は注釈しなければならない
    // コンパイラに ジェネリックライフタイム引数を使って関係を注釈して、
    // 実行時に「実際の参照が確かに有効であること」を保証しなければならない
    // ライフタイムの概念は、他のプログラミング言語の道具とは異端で 確実で Rust で1番際立つ機能となる

    // 今回でライフタイムの全体を解説することはない。ライフタイム記法が必要となる最も一般的な場合について学ぶ
    // ライフタイムの概念に馴染めるといいな( 'ω')

  // ライフタイムでダングリング参照を回避する
    // ライフタイムの主な目的は ダングリング参照を回避すること
    // ダングリング参照により プログラムが参照するつもりだったデータ以外のデータを参照してしまう
    // 以下は 外側のスコープと内側のスコープが含まれている

    // [NOTE] 値は生まれたスコープの終端に当たると死ぬ

    /*
    { //  外側のスコープ
        let r;
        { // 内側のスコープ
            let x = 5;
            r = &x;
        }
        println!("{}", r);
    }
    */

    //*note: 変数に初期値を与えずに宣言しているので 変数名は外側のスコープに存在する
    //       これは「Rust には null値が存在しない」ということと衝突してるように見えるかもしれない
    //       値を与える前に変数を使おうとすれば コンパイルエラーになる。これは Rust では null値は許可されないから

    // 外側のスコープで初期値なしの変数r を宣言して 内側のスコープで初期値が5の変数x を宣言している
    // 内側のスコープ内で r の値を xへの参照にしようとしている
    // それから内側のスコープが終わって r の値を出力しようとしている
    // r が参照している値が既にスコープを抜けるので このコードはコンパイルできない
    // つまり x の値を参照してるのに その x が既に drop(死亡) しててエラーってこと
    // こちらがエラーメッセージ

    /*
    error[E0597]: `x` does not live long enough // 訳: x の生存期間が短すぎる
      --> src/main.rs:X:X
       |
    X  |         r = &x;
       |              - borrow occurs here // 訳: 借用はここで起きている
    X  |     }
       |     ^ `x` dropped here while still borrowed // 訳: x は借用されている間にここでドロップ
    ...
    X  | }
       | - borrowed value needs to live until here // 訳: 借用された値はここまで生きる必要がある
    */

    // 変数x の「生存期間が短すぎる」の原因は、内側のスコープが終わった時点で x がスコープを抜けること
    // ですが r はまだ 外側のスコープに対して有効。スコープが大きいので「長生きする」と言う
    // Rust で このコードが動けたら r は x がスコープを抜けた時に解放されるメモリを参照していることになり、
    // r でやりたいことが正常に動作しない。ならばどの様にコンパイラは このコードが無効であると決定しているか。借用チェッカーを使用している
}