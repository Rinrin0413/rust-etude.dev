#[allow(unused)]
pub fn lifetime() {
 // ライフタイムで参照を検証する
    // 参照や借用 において 一つ重要な詳細を説明していなかった
    // Rust において参照は 全てライフタイムを保持している
    // ライフタイムとは その参照が有効になるスコープのこと
    // 多くの場合、型が推論されるのと同じく ライフタイムも暗黙的に推論される
    // 複数の型が推論される場合は 型を注釈する必要があった
    // 同様に、参照のライフタイムが 幾つかの方法で関係する可能性がある場合は注釈しなければならない
    // コンパイラに ジェネリックライフタイム引数を使って関係を注釈して、
    // 実行時に「実際の参照が確かに有効であること」を保証しなければならない
    // ライフタイムの概念は、他のプログラミング言語の道具とは異端で 確実で Rust で1番際立つ機能となる

    // 今回でライフタイムの全体を解説することはない。ライフタイム記法が必要となる最も一般的な場合について学ぶ
    // ライフタイムの概念に馴染めるといいな( 'ω')

  // ライフタイムでダングリング参照を回避する
    // ライフタイムの主な目的は ダングリング参照を回避すること
    // ダングリング参照により プログラムが参照するつもりだったデータ以外のデータを参照してしまう
    // 以下は 外側のスコープと内側のスコープが含まれている

    // [NOTE] 値は生まれたスコープの終端に当たると死ぬ

    /*
    { //  外側のスコープ
        let r;
        { // 内側のスコープ
            let x = 5;
            r = &x;
        }
        println!("{}", r);
    }
    */

    //*note: 変数に初期値を与えずに宣言しているので 変数名は外側のスコープに存在する
    //       これは「Rust には null値が存在しない」ということと衝突してるように見えるかもしれない
    //       値を与える前に変数を使おうとすれば コンパイルエラーになる。これは Rust では null値は許可されないから

    // 外側のスコープで初期値なしの変数r を宣言して 内側のスコープで初期値が5の変数x を宣言している
    // 内側のスコープ内で r の値を xへの参照にしようとしている
    // それから内側のスコープが終わって r の値を出力しようとしている
    // r が参照している値が既にスコープを抜けるので このコードはコンパイルできない
    // つまり x の値を参照してるのに その x が既に drop(死亡) しててエラーってこと
    // こちらがエラーメッセージ

    /*
    error[E0597]: `x` does not live long enough // 訳: x の生存期間が短すぎる
      --> src/main.rs:X:X
       |
    X  |         r = &x;
       |              - borrow occurs here // 訳: 借用はここで起きている
    X  |     }
       |     ^ `x` dropped here while still borrowed // 訳: x は借用されている間にここでドロップ
    ...
    X  | }
       | - borrowed value needs to live until here // 訳: 借用された値はここまで生きる必要がある
    */

    // 変数x の「生存期間が短すぎる」の原因は、内側のスコープが終わった時点で x がスコープを抜けること
    // ですが r はまだ 外側のスコープに対して有効。スコープが大きいので「長生きする」と言う
    // Rust で このコードが動けたら r は x がスコープを抜けた時に解放されるメモリを参照していることになり、
    // r でやりたいことが正常に動作しない。ならばどの様にコンパイラは このコードが無効であると決定しているか。借用チェッカーを使用している

  // 借用精査機
	// Rustコンパイラには、スコープを比較して 全ての借用が有効であるかを決定する借用チェッカーがある
   	// 以下は 先ほどと同じコードに 変数のライフタイムを表示する注釈が付いている

    /*
    {
        let r;                // --------+- 'a   // a誕生🎊
        {                     //         |
            let x = 5;        // -+- 'b  |       // b誕生🎊
            r = &x;           //  |      |
        }                     // -+      |       // b死亡✞
        println!("{}", r);    //         |
    }                         // --------+       // a死亡✞
    */

    // ここで rのライフタイムは 'a 、xのライフタイムは 'b として注釈した
    // ご覧の通り 内側の 'b の方が 外側の 'a より遥かに短命
    // コンパイル時に コンパイラは2つのライフタイムのサイズを比較し、
    // r は 'a のライフタイムだが、'b のライフタイムのメモリを参照していると確認する
    // 'b は 'a よりも短命な故 プログラムは拒否される。参照の対象が参照の様には長生きしていない
    // 以下はコードを修正したので、ダングリング参照はなくなってエラーなくコンパイルできる

    {
        let x = 5;            // ---------+- 'b   // 'b誕生🎊
        let r = &x;           // --+- 'a  |       // 'a誕生🎊
        println!("r: {}", r); //   |      |
    }

    // ここで xのライフタイムは 'b であり、'a よりも大きい
    // つまり コンパイラは x が有効な間 r の参照も常に有効になると把握している故 rはxを参照できる
    // 今や 参照のライフタイムがどのくらいあって コンパイラが「ライフタイムを解析して参照が常に有効である」とを保証する仕組みがわかったので、
    // 関数の文脈でジェネリック引数と戻り値のライフタイムを探究する

  // 関数のジェネリックなライフタイム
    // 2つの文字列スライスのうち 長い方を返す関数を書く
    // この関数は 2つの文字列スライスを取り 1つの文字列スライスを返す
    // longest関数の実装すれば `The longest string is abcd` と出力される

    /*
    let string1 = String::from("abcd");
    let string2 = "xyz";
    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result); //< The longest string is abcd
    */

    // 関数に取ってほしい引数が 文字列スライス つまり参照であることに注意(&str)
    // 何故なら longest関数に 引数の所有権を奪ってほしくない故
    // この関数に String型のスライス と 文字列リテラル を受け取らせている
    // 以下の様に longest関数を実装しようとしたら コンパイルはできない

    /*
                                    ┏ この参照の元が不明 
    fn longest(x: &str, y: &str) -> &str {
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    */

    // 代わりに ライフタイムについて言及するエラーが出る
    /*
    error[E0106]: missing lifetime specifier // 訳: ライフタイム指定子が不足している
     --> src/main.rs:X:X
      |
    X | fn longest(x: &str, y: &str) -> &str {
      |                                 ^ expected lifetime parameter // 訳: ライフタイム引数が予想される
      |
      = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
            // ┗ 訳: この関数の戻り値型は借用された値を含んでいるが シグネチャでそれが x由来なのか y由来のものなのか宣言していない
    */


    // 助言(note)で 戻り値の型はジェネリックなライフタイム引数でなければならないと示している
    // というのも、返している参照が x か y のどちらを参照しているかが コンパイラには分からない
    // この関数の本体の ifブロックは x への参照を返し、
    // elseブロックは y への参照を返すので 実際どちらの参照が返されるかは私たちにもわからない

    // この関数を定義する際に 渡される具体的な値が分からないので ifケースか elseケースどちらで返却されるか分からない
    // また、渡される参照の具体的なライフタイムも分からない故、
    // 返す参照が常に有効であるかを決定したように スコープを見ることもできない
    // 借用チェッカーもこれを決定することはできない。x と y のライフタイムがどう戻り値のライフタイムと関係するか分からない故
    // このエラーを修正するには 借用チェッカーが解析を実行できるように 参照間の関係を定義するジェネリックなライフタイム引数を追加する

  // ライフタイム注釈記法
    // ライフタイム注釈が 参照の生存期間を変えることはない
    // ジェネリック型引数を宣言された関数が あらゆる型を受け取ることができるのと同じく、
    // ジェネリックなライフタイム引数を指定された関数は あらゆるライフタイムの参照を受け取ることができる
    // ライフタイム注釈は ライフタイムに影響せずに 複数の参照のライフタイムのお互いの関係を記述する

    // ライフタイム注釈は 少し不自然な記法です
    // ライフタイム引数の名前は `'` で始まらなければならず、通常全部小文字で ジェネリック型のように短ㄑ表記する
    // 多くの人は 'a という名前を使う。ライフタイム引数注釈は 参照の `&` の後に配置し 注釈と参照の型を区別するために半角空白を1つ置く
    // 以下は ライフタイム引数なしのi32への参照, 'aというライフタイム引数付きのi32への参照 そしてライフタイム'a付きのi32への可変参照

    /*
    &i32        // ただの参照
    &'a i32     // 明示的なライフタイム付きの参照
    &'a mut i32 // 明示的なライフタイム付きの可変参照
    */

    // 1つのライフタイム注釈それだけでは 大して意味はない
    // 注釈は 複数の参照のジェネリックなライフタイム引数が お互いにどう関係するかをコンパイラに指示するもの
    // 例えば ライフタイム'aの付いたi32への参照となる引数firstのある関数があるとする
    // この関数にはさらに、ライフタイム'aの付いたi32への別の参照となる引数second もある
    // ライフタイム注釈は first と second の参照がどちらも このジェネリックなライフタイムと同じだけ生きることを示唆する(同じライフタイム'aを使っているため)

  // 関数シグニチャにおけるライフタイム注釈
    // さて longest関数を例に ライフタイム注釈を詳しく見ていく
    // ジェネリック型引数と同じく 関数名と引数リスト(丸括弧の奴)の間の<>の中に ジェネリックなライフタイム引数を宣言する
    // このシグニチャで表現したい制約は 引数の全ての参照と戻り値が同じライフタイムを持つこと
    // 以下の様に、ライフタイムを'aと名付けて それを各参照に付与する

    //          ┏ ライフタイム'a の宣言
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
	//                 ┗━━━━━━━━━━━┻━━━━━━━━━━━┻━ ライフタイム'a を付与
		if x.len() > y.len() {
			x
		} else {
			y
		}
	}

    // このコードはコンパイルでき、望んだ動きをするはず
    let string1 = String::from("abcd");
    let string2 = "xyz";
    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result); //< The longest string is abcd
}