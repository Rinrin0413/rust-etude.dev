#![allow(unused)]
    // Rust はエラー処理においても优秀です
    // ソフトウェアにおいてエラーは生きている証し
    // なので Rust には何かがおかしくなる場面を扱う機能がたくさんある
    // 様々な場面でコンパイラはプログラマに エラーの可能性を知ってコンパイルが通るまでに対応をできるように要求してくる
    // それによりエラーを発見してコードをリリースする前に適切に対処出来ていることを確認することでプログラムを頑健なものにできる

    // Rust ではエラーは大きく分けて2種類ある
    // 回復可能と回復不能なエラーです
    // ファイルが見つからない等の回復可能なエラーでは 問題をユーザに報告し処理を再試行することができる
    // 回復不能なエラーは配列の境界を超えた箇所へのアクセスなどでバグの兆候

    // 多くの言語ではこの2種のエラーを区別することはあまりない
    // 例外などの機構を使用して同様に扱う
    // Rust には例外が存在しない代わりに回復可能なエラーには Result<T, E>値がある
    // プログラムが回復不能なエラーに遭遇した際に実行を中止するpanic!マクロがある
    // このではまず panic! の呼び出しについて学び、それから Result<T, E>を戻り値にする方法を学ぶ
    // 加えて エラーからの回復を試みるか、実行を中止するか決定する際に 考慮すべき事についても学ぶ
pub fn panic() {
   // panic!で回復不能なエラー
    // 時としてコードで悪いことは起こる。そしてそれに対してできることは何もない
    // 贵樣ばどラずゑこともできなぃ:()
    // このような場面の時の為に panic!マクロが用意されている
    // panic!マクロが実行されると プログラムは失敗のメッセージを表示し スタックを巻き戻し掃除して 終了する
    // これがよく起こるのは何らかのバグが検出された時で、我々はどうエラーを処理すればいいかはっきりしない

    // パニックに対してスタックを巻き戻すか異常終了するかについて
        // 標準ではパニックが発生するとプログラムは巻き戻しを始める
        // つまり言語がスタックを遡って遭遇した各関数のデータを片付けるということ
        // しかしこの遡りと片付けはすべきことが多くなる
        // 対策としては即座に異常終了して片付けをせずにプログラムを終了させること
        // こうなるとプログラムが使用していたメモリは OS が片付けることになる
        // プロジェクトにおいて実行可能ファイルを極力小さくする必要があれば、
        // Cargo.toml の [profile]欄 に `panic = 'abort'` を追記することでパニック時に巻き戻しから異常終了するように切り替えることができる
        // 例えばリリースモード時に異常終了するようにしたければ以下を追記することになる
        //[profile.release]
        //panic = 'abort'

    // 取り敢えず呼ぶ
    //panic!("クラッシュして大炎上");
    // こうなると以下のエラーが出る
    //thread 'main' panicked at 'クラッシュして炎上', src\main.rs:41:5
    //note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
    // panic! の呼び出しがこのエラーメッセージを発生させている
    // 上の1行目でパニックメッセージとパニックが発生した箇所を表していて、src/main.rs41:5は src/main.rsの41行目の5文字目で起こったという意味
    // この場合表される行は自分のコードの一部なのでその箇所を見に行けば panic!マクロがあるってこと
    // また、panic! が自分のコードが呼び出しているコードの一部になっている可能性もある
    // その場合 報告されるファイル名と行が、panic! の呼び出しに導いた panic!マクロを呼び出している他人のコードとなる
    // panic! の発生元である関数のバックトレースを使用して問題を起こしている自分のコードの箇所を割り出すことができる
    // バックトレースがどんなものか学びませう

   // panic!バックトレースを使用する
    // 別の例でライブラリで panic!呼び出しが発生するとどうなるか診てみる
    // 添え字でベクタの要素にアクセスを試みるコードです
    let v = vec![1, 2, 3];
    //v[99]; // 範囲外へのアクセスでパニック
    // ここではベクタの100番目の要素へのアクセスを試みているがベクタには3つしか要素がない
    // このコードでは Rustはパニックする
    // []の使用は要素を返すと想定されるが 無効な添え字を渡せば Rust が返せて正しいと思われる要素は何もない

    // 他の言語(例えばC言語)ではこの場面で欲しいものではないのにまさしく要求したものを返そうとしてくる
    // メモリがベクタに属していないのにベクタ内のその要素に対応するメモリ上の箇所にあるものを何か返してくる(ガバガバで草)
    // これはバッファー外読み出しと呼ばれていて、
    // 悪人が配列の後に格納された読めるべきでないデータを読み出せるように添え字を操作できれば セキュリティの脆弱性につながる
    // この様な脆弱性からプログラムを保護するためにも、
    // 存在しない添え字の要素を読もうとしたら Rust は実行を中止して継続を諦める
    // 以下のエラーは自分のものではない vec.rs ファイルを指す
    /*
    $ cargo run
       Compiling panic v0.1.0 (file:///projects/panic)
        Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
         Running `target/debug/panic`
    thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
    99', /checkout/src/liballoc/vec.rs:1555:10
    note: Run with `RUST_BACKTRACE=1` for a backtrace.
    */
    // 標準ライブラリの Vec<T> の実装です
    // ベクタv に対し[]を使った時に走るコードは vec.rs にありここで実際に panic! が発生している(ソース: let v = vec![1, 2, 3];v[99];)
    // その次の注釈行(note)は RUST_BACKTRACE環境変数をセットして 何が起きてエラーが発生したかのバックトレースを得られることを教えてくれている

    // バックトレースとはここに至るまでに呼び出された全関数の一覧。/*#バックトレース*/
    // Rust のバックトレースも他言語同様に動作する。バックトレースを読むコツは 頭からスタートして自分のファイルを見つけるまで読むこと
    // そこが問題の根源になる。自分のファイルを表している場所以前は自分のコードで呼び出したコードになり、以後は自分のコードを呼び出しているコードになる
    // これらの行には Rust の核となるコードや std のコードや使用しているクレートなどが含まれる可能性がある
    // RUST_BACKTRACE環境変数を0以外の値にセットしてバックトレースを出力してみると以下のように出力される
/*
    $ RUST_BACKTRACE=1 cargo run
        Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
         Running `target/debug/panic`
    thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /checkout/src/liballoc/vec.rs:1555:10
    stack backtrace:
       0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace
                 at /checkout/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:49
       1: std::sys_common::backtrace::_print
                 at /checkout/src/libstd/sys_common/backtrace.rs:71
       2: std::panicking::default_hook::{{closure}}
                 at /checkout/src/libstd/sys_common/backtrace.rs:60
                 at /checkout/src/libstd/panicking.rs:381
       3: std::panicking::default_hook
                 at /checkout/src/libstd/panicking.rs:397
       4: std::panicking::rust_panic_with_hook
                 at /checkout/src/libstd/panicking.rs:611
       5: std::panicking::begin_panic
                 at /checkout/src/libstd/panicking.rs:572
       6: std::panicking::begin_panic_fmt
                 at /checkout/src/libstd/panicking.rs:522
       7: rust_begin_unwind
                 at /checkout/src/libstd/panicking.rs:498
       8: core::panicking::panic_fmt
                 at /checkout/src/libcore/panicking.rs:71
       9: core::panicking::panic_bounds_check
                 at /checkout/src/libcore/panicking.rs:58
      10: <alloc::vec::Vec<T> as core::ops::index::Index<usize>>::index
                 at /checkout/src/liballoc/vec.rs:1555
      11: panic::main
                 at src/main.rs:4
      12: __rust_maybe_catch_panic
                 at /checkout/src/libpanic_unwind/lib.rs:99
      13: std::rt::lang_start
                 at /checkout/src/libstd/panicking.rs:459
                 at /checkout/src/libstd/panic.rs:361
                 at /checkout/src/libstd/rt.rs:61
      14: main
      15: __libc_start_main
      16: <unknown>
    */
    // 出力が多いです。OS や Rust のバージョンにより出力の詳細は変わる可能性がある
    // この情報とともにバックトレースを得るにはデバッグシンボルを有効にしなければいけない
    // デバッグシンボルは --releaseオプションなしで cargo build や cargo run を使用すれば標準で有効になる
    // 上の出力でバックトレースの11行目が問題発生箇所を指し示している
    // src/main.rs の4行目となる。プログラムにパニックして欲しくないなら、
    // 自分のファイルについて書いてある 最初の行で示されている箇所こそが どんなパニックを引き起こす値で、
    // どうこの箇所にたどり着いたかを割り出すため、調査を開始すべき箇所になる

    // バックトレースの使用法を示す為に故意にパニックするコードを書いた節冒頭のコードにおいて、((ソース: let v = vec![1, 2, 3];v[99];))
    // パニックを解消する方法は範囲外へのアクセスを止めること。将来コードがパニックしたら、
    // パニックを引き起こす物が どんな値で どんな動作 をしているのかと、
    // そしてコードに何をすべきなのかを考える必要がある
    
    // 次は Result を使用してエラーから回復する方法について考える
}

pub fn result() {
  // Resultで回復可能なエラー
    // プログラムを完全にストップさせるほど深刻なエラーはあまり無い
    // 時々 処理の中でエラーに対応できることがある
    // 例えばファイルを開こうとしたが 目標のファイルが存在しなくて処理に失敗したら、
    // プロセスを停止するのではなくファイルを作成したりできる
    // Result の enum が Ok と Err の2列挙子からなるよう定義されていることを思い出してください
    //enum Result<T, E> { Ok(T), Err(E), }
    // T と E はジェネリックな型引数です。ジェネリクスについはもうじき議論する
    // 今知っておいて欲しいのは T が成功した時に Ok列挙子に含まれて返される値の型を表すことと、
    // Eが失敗した時に Err列挙子に含まれて返されるエラーの型を表すこと
    // Result はこのようなジェネリックな型引数を含むため std上に定義される Result型や関数などを成功時とエラー時で返す値を分けられる
    // 関数が失敗する可能性があるので Result値を返す関数を呼び出す

    // 以下ではファイルを開こうとしている
    use std::fs::File;
    let f = File::open("hello.py");

    // File::open が Result を返したものをどう取得するのでしょう
    // std の APIドキュメントでも知ることができ、 コンパイラに尋ねることもできる(vscなら変数をホバーするだけで型がわかる)
    // f に戻り値ではないと分かる型注釈を与えコードのコンパイルをしようとすれば、
    // コンパイラが「型が合わない」と教えてくれう。そしてエラーメッセージでは f の実際の型を教えてくれる
    // 試してみる
    // File::open の戻り値の型は u32 ではないと分かっているので let文を臨時で以下のように変更してみる
    //let f_ii:u32 = File::open("hello.py");
    // エラー↓

    /*
    error[E0308]: mismatched types
       --> src\main.rs:164:20
        |
    164 |     let f_ii:u32 = File::open("hello.py");
        |              ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `std::result::Result`
        |              |
        |              expected due to this
        |
        = note: expected type `u32`
                   found enum `std::result::Result<File, std::io::Error>`
    */

    // これで File::open関数の戻り値の型は Result<T, E> であることが判明した
    // ジェネリック引数の T は成功値の型 std::fs::File で埋められていて、これはファイルハンドル
    // エラー値で使用されている E の型は std::io::Error
    // この戻り値型は File::open の呼び出しが成功して 読込と書込を行えるファイルハンドルを返せるということを表す
    // また 関数呼出は失敗もする可能性がある。例えばファイルが存在しない可能性, ファイルへのアクセス権限がない可能性などによるもの
    // File::open には 成功したか失敗したかを知らせる方法 と ファイルハンドルまたはエラー情報を与える方法 が必要
    // この情報こそが Result enum が伝達するもの

    // File::open が成功した場合 変数f の値はファイルハンドルを含むOkインスタンスになる
    // 失敗した場合 エラーの種類の情報を多く持つ Errインスタンスが f の値になる
    // 初めのコードに追記をして File::open が返す値に応じ 異なる動作をする必要がある
    // 以下は基礎的な道具(match式)を使って Result を扱う方法を一つ示している
    let f_iii = File::open("./static/hello.py");
    let f_iii = match f_iii { // f_iiiの戻り値 ( つまりFile::open()の返り値 ) に応じて条件分岐
        Ok(file) => file, // Ok値が返されたらそのまま返す
        Err(error) => panic!("ファイルを開く時に問題が発生: {:?}", error), // Err値が返されたら エラー文を返す
    };
    // Option enum と同じく Result enum とその列挙子は初期化処理でインポートされている故、
    // matchアーム内で Ok と Err列挙子の前に Result:: を書かなくてもよい
    // ここでは結果が Ok の時に Ok列挙子から中身の file値を返すように指示し、
    // それからそのファイルハンドル値を変数f_iii に代入している match の後にはファイルハンドルを使用して読み込んだり書き込むことができる
    // match のもう1つのアームは File::open から Err値与えらっれたときに処理される
    // この例では panic!マクロを呼び出している。カレントディレクトリ(現在のdir)に hello.py というファイルがなく、
    // このコードを走らせたら panic!マクロからの以下のような出力される
    //thread 'main' panicked at 'ファイルを開く時に問題が発生: Os { code: 2, kind: NotFound, message: "指定されたファイルが見つかりません。" }', src\main.rs:197:23
    // この出力は一体何がおかしくなったのかを物語っている

   // 色々なエラーにマッチする
    // 先程のコードは File::open が失敗した理由にかかわらずパニックさせている
    // 失敗理由によって動作を分岐したいとする
    // ファイルが存在しない故 File::open が失敗したらファイルを作成してその新しいファイルへのハンドルを返したい
    // 他の理由(例えばファイルを開く権限が無いなど)で File::open が失敗したらパニックさせたい
    // 以下を見てください。ここでは match に別のアームを追加している
    use std::io::ErrorKind;
    let f_iv = File::open("./static/hello.py");
    let f_iv = match f_iv { // ファイル取得においてのエラーの有無で分岐
        Ok(file) => file, // 問題なければそのままファイルのハンドルを返す
        Err(ref error) if error.kind() == ErrorKind::NotFound => { // エラーNotFound だった場合
            match File::create("./static/hello.py") { // ファイルを作成する
                Ok(fc) => fc, // 成功すればそのファイルのハンドルを返す
                Err(e) =>  panic!("ファイル作成を試みたが問題が発生: {:?}", e), // 作成に失敗でパニックさせる
            }
        },
        Err(error) => panic!("ファイルを開く時に問題が発生: {:?}", error), // それ以外のエラー
    };
    println!("{:?}", f_iv); //< File { handle: 0xa8, path: "\\\\?\\root\\static\\hello.py" }

    // File::open が Err列挙子に含めて返す値の型は io::Error型
    // これは std で提供されている構造体。これには io::ErrorKind値が得られる kindメソッドがある
    // io::ErrorKind という enum は std で提供されていて io処理から発生する色々な種類のエラーを表す列挙子がある
    // 今回使用したい列挙子は開こうとしているファイルがまだ存在しないことを示唆する ErrorKind::NotFound

    // if error.kind()==ErrorKind::Notfound という条件式はマッチガードと呼ばれる /*#マッチカード*/
    // アームのパターンをさらに洗練する matchアーム上のおまけの条件式
    // この条件式はそのアームのコードが実行される上で真でなければならない
    // そうでなければそのアームはスルーされ次に行きます
    // パターンの ref は error がガード条件式にムーブされないように必要だが ただ単にガード式に参照されるだけ
    // ref を使用して & の代わりにパターン内で参照を作っている理由はいずれ学ぶ
    // 簡単に言うとパターンの文脈において & は参照にマッチしその値を返すが、
    // ref は値にマッチしてそれへの参照を返すということ。

    // マッチガードで精査したい条件は　error.kind()の返り値が ErrorKind enum の NotFound列挙子であるかということ
    // もしそうなら File::create でファイル作成を試みる。しかし File::create も失敗する可能性がある故、
    // 内部にも match式を追加する必要がある。ファイルが開けないなら異なるエラーメッセージが出力される
    // 外側の match の最後のアームは同じままなのでファイルが存在しないエラー以外ならプログラムはパニックする

   // エラー時にパニックするショートカット: unwrap と expect
    // match の使用は十分合理的だが、長くなりすぎたり必ずしも意図をよく伝えるとは限らない
    // Result<T,E>型には色々な作業をするヘルパーメソッドが多く定義されている

    // それらの関数の1つとして unwrap がある。match式と同じように実装された短絡メソッド
    // Result値が Ok列挙子なら unwrap は Ok の中身を返し、
    // Resultが Err列挙子なら unwrap は panic!マクロを呼ぶ
    // こちらが実際に動作している unwrap の例
    let f_v = File::open("./static/hello.py").unwrap();

    // 別のメソッド expect は unwrap に似ているが panic!のエラーメッセージも選べる
    let f_vi = File::open("./static/hello.py").expect("./static/hello.py を開くのに失敗");
    // expect もファイルハンドルを返したり panic!マクロの呼出をする
    // expect が panic!呼出で使用するエラーメッセージは unwrap が使うデフォルトの panic!メッセージではなく、 
    // expect に渡した引数になる
    // 例えば参照先ファイルを存在しない "./static/ahello.py" にした場合以下のようなエラーメッセージが出力される
    //thread 'main' panicked at './static/hello.py を開くのに失敗: Os { code: 2, kind: NotFound, message: "指定されたファイルが見つかりません。" }', src\main.rs:259:49
    // このエラーメッセージは自分で指定した物なのでどこでエラーメッセージが出力されたのかが分かりやすくなる
    // 複数箇所で unwrap を使用していたら ズバリどのunwrapがパニックを引き起こしているのかを探すのに時間がかかります
    // パニックする unwrap 呼出では全て同じメッセージを出力する故

  // エラーを委譲する
    // 失敗するかもしれない何かを呼ぶ関数を書く際に、
    // 関数内でエラーを処理する代わりに その後どうするかを呼出元が決めれるようにエラーを返すことができる
    // これをエラーの委譲といい  自分のコードの文脈で利用可能なものより、
    // エラーの処理法を規定する情報やロジックがより多くある呼び出し元のコードに制御を任せる
    // 例えば以下のの関数はファイルからユーザ名を読み取る
    // ファイルが存在しなかったり読み込みできなければ この関数はそれに合ったエラーを呼び出し元のコードに返す
    use std::io::{ self, Read };
    fn read_username_from_file() -> Result<String, io::Error> {
        let f_vii = File::open("./static/name.txt");
        let mut f_vii = match f_vii { // ファイルの読み込みの成功の合否で分岐
            Ok(file) => file,
            Err(e) => return Err(e), // 失敗した時点で Err値(io:Error)を返して関数の処理を終了
        };
        let mut s = String::new();
        match f_vii.read_to_string(&mut s) { // read_to_string関数でファイルハンドルから内容の取得とsへの書込を試みて、
            Ok(_) => Ok(s), // 成功したら Okケースに包まれた目標の名前を返して
            Err(e) => Err(e), // 失敗したら Err値(io:Error)を返す
        }
    }

    // まず関数の戻り値型に注目してください。 Result<String, io::Error> です
    // つまりこの関数は Result<T, E>型の値を返しているということになる
    // ここでジェネリック引数の T は具体型String が入る
    // ジェネリック引数の E は具体型io::Error が入る

    // この関数が何の問題もなく動けば String(ファイルから読取ったユーザ名)を保持するOk値が返される

    // この関数で何か問題に行き当たったら io::Error のインスタンスを保持するErr値を返す。
    // この io::Error は問題の内容に関する情報を多く含んでいる
    // 関数の戻り値の型に io::Error を選んだのは、
    // この関数で呼出している 失敗する可能性のある処理[※¹]が 両方とも偶然この型(io::Error)をエラー値として返す故
    // ※¹ : File::open関数と read_to_stringメソッド

    // 関数の本体は File::open関数の呼出から始まる
    // そして match で返ってくる Result値を扱って Err値が来たら関数から早期リターンして、
    // エラー値として File::open から得たエラー値を返す
    // File::open が成功すればファイルハンドルを変数f_vii に保管して継続する

    // そして可変変数s に空の String を生成して、
    // f_vii のファイルハンドルに対し read_to_string を呼び出しファイルの中身を s に読み出す
    // File::open に成功していても read_to_stringメソッドでも失敗する可能性があるので、
    // また Result を返却する。その Result を処理するために別の match が必要になる
    // read_to_string が成功したら 関数は成功し今は Ok に包まれた s に入っているファイルのユーザ名を返す
    // read_to_string が失敗したら File::open の方と同じ様にエラー値を返す
    // しかし 明示的に return を述べる必要はない。これが関数の最後の式故に

    // そしたら関数を呼び出したのコードは ユーザ名を含む Ok値か、io::Error を含む Err値を得ることができる
    // しかしその値が何に使われるかはわからない
    // もし Err値を得たら panic! を呼び出してプログラムをクラッシュさせるかもしれないし、
    // 取得できたユーザー名で名簿を作るかもしれない
    // 取得された値が実際何に使われるにかついては推測できない故、
    // 成功や失敗情報を全て委譲して適切に扱えるようにする必要がある

    // Rust ではこの様なエラー委譲は頻繁に行われるので、
    // これをしやすくする ?演算子が用意されている

   // エラー委譲のショートカット: ?演算子
    // 以下も同じ機能を read_username_from_file関数の実装だが ?演算子を使用している
    fn read_username_from_file_ii() -> Result<String, io::Error> {
        let mut f = File::open("hello.txt")?;
        let mut s = String::new();
        f.read_to_string(&mut s)?;
        Ok(s)
    }
    // Result値の直後に置かれた `?` は先程まで match式で行っていた「成功合否による分岐」とほぼ同じように動作する
    // Result値が Ok なら Ok の中身がこの式から返されてプログラムは継続する、
    // 値が Err なら Errの中身を早期リターンさせてエラー値は呼び出し元のコードに委譲される

    // ただし先程までの match式での実装と ?演算子での実装には違いがある
    // `?` を使ったエラー値は std の Fromトレイトで定義されていてエラーの型を別のものに変換する from関数を通る
    // ?演算子が from関数を呼び出すと受け取ったエラー型が 関数の戻り値型として定義されている型に変換される
    // これは個々が様々な理由で失敗する可能性があるのにも関わらず、
    // 関数が失敗する可能性を全て1つのエラー型で表現して返す時に有用
    // 各エラー型が from関数を実装して返り値のエラー型への変換を定義している限り ?演算子が変換の面倒を自動的に見てくれる

    // 上のコードでは File::open呼出末尾の `?` は Ok の中身を変数f に返す
    // エラーが発生したら ?演算子により関数全体から早期リターンしてあらゆる Err値を返す
    // 同じ法則が read_to_string 呼出末尾の `?` にも適用される
    // ?演算子により定型コードの多くが排除されて関数の実装を単純にできる

    // 以下の様に `?` の直後のメソッド呼出を連結することで更にコードを短くすることができる
    fn read_username_from_file_iii() -> Result<String, io::Error> {
        let mut s = String::new();
        File::open("hello.txt")?.read_to_string(&mut s)?;
        Ok(s)
    }
    // s の新規 Stringの生成を関数の冒頭に移動した
    // 変数f を生成する代わりに read_to_string に直接 連結させた

   // ?演算子は、Resultを返す関数でしか使用できない
    // ?演算子に惚れたかと思いますが そんなあなたに悲報です
    // ?演算子は戻り値に Result を持つ関数でしか使用できない
    // というのも序盤でやっていた様な match式での分岐と同様に動作するよう 定義されている
    // Result の戻り値型を要求する matchの部品は `return Err(e)` なので、
    // 関数の戻り値はこの return と互換性を保つため Result でなけらばならない

    // ここまで panic!呼出や Result を返す詳細について学んだので、
    // いつどこでどんなときにどちらを使うべきなのかを学ぶ

    // Result値を返す決定をするということは選択肢を与えることになる
    // 呼出側は 状況に合わせ回復を試みたり、
    // 特定の Err値は回復不能と断定して panic! を呼び出して 回復可能だったはずのエラーを回復不能にさせることもできる
    // 故に Result を返却するということは  失敗する可能性のある関数を定義する際において いい選択肢になる

    // 稀に Result を返すよりもパニックするコードを書く方がより適切になることもある
    // 例やプロトタイプコード, テストでパニックするのが適切な理由を探ってみる 
}

pub fn panic_or_not() {
  // panic!すべきかするまいか
    // panic! すべきなのか Result を返すべきなのかはどう決めればいいのでしょう
    // コードがパニックしたら回復不能
    // 回復手段の有無に関わらず どんなエラーでも panic! を呼ぶことができるが、
    // これは回復不能という決定を下すことになる

    // Result値を返す決定をするということは選択肢を与えることになる
    // 呼出側は 状況に合わせ回復を試みたり、
    // 特定の Err値は回復不能と断定して panic! を呼び出して 回復可能だったはずのエラーを回復不能にさせることもできる
    // 故に Result を返却するということは  失敗する可能性のある関数を定義する際において いい選択肢になる

    // 稀に Result を返すよりもパニックするコードを書く方がより適切になることもある
    // 例やプロトタイプコード, テストでパニックするのが適切な理由を探ってみる 

   // 例、プロトタイプコード、テスト
    // match式でエラーの種類によって分岐したりしても 頑健なエラー処理コードも巻き込んでしまえば それは損失となりかねない

    // unwrap などのパニックする可能性のあるメソッド呼出は、
    // アプリケーションに エラー処理をしてほしい方法へのプレースホルダー(元々値が入ってるフォームとかのこと) を意味していると理解され、
    // これは残りのコードがしていることによって異なる可能性がありる(?)
    // 同様に unwrap や expectメソッドはエラーの処理法を決定する準備ができる前 つまりプロトタイプの段階では非常に便利
    // それによりコードにプログラムをより頑健にする時の明らかなマーカーが残される

    // つまり unwrap などは とりま適当にあしらうときに使う物ということ
    // しかしリリース時点であってはだめ というわけではない

    // テスト内でメソッド呼出に失敗したら そのメソッドがテストじゃないとしても テスト全体が失敗してほしいはず
    // panic! はテストの失敗を表すので unwrap や expect の呼び出しはスバリ起こるべきこと

   // コンパイラよりもプログラマがより情報を持っている場合
    // Result が Ok値だと確認する別のロジック(処理法)がある場合、
    // unwrap を呼び出すことは適切かもしれないが コンパイラはそのロジックを理解しない
    // それでも処理しなければならない Result は存在する
    // 呼び出している処理が何であれ 自分の特定の場面では論理的に起こり得なくても 一般的にまだ失敗する可能性はある
    // 手動でコードを調査して Err列挙子は存在しないと確認できたら unwrap の呼び出しは合法となる
    // 以下が例
    use std::net::IpAddr;
    let home:IpAddr = "127.0.0.1".parse().unwrap(); // std::net::IpAddr型

    // ハードコード(デバッグ)された文字列を構文解析して IpAddrインスタンスを生成している
    // プログラマには 127.0.0.1 が合法なIPアドレスなのが分かる故 ここで unwrap を使用することは合法なはず
    // しかしハードコードされた合法な文字列が存在することは parseメソッドの戻り値型を変えることにはならない
    // それでも得られるのは Result値であり コンパイラはまだ Err列挙子になる可能性があるかの如く Result を処理させようとしてる
    // コンパイラはこの文字列が常に合法な IPアドレスであると把握できるほど天才ではない
    // プログラムにハードコードされるのではなく IPアドレス文字列がユーザ起源なので 確実に失敗する可能性があるなら、 
    // Result をもっと頑健な方法で処理した方がいい

   // エラー処理のガイドライン
    // 悪い状態になるかもしれないときにパニックさせるのは推奨されること
    // ここでの悪い状態とは 何らかの前提, 保証, 契約, 不変性が破られたことであり、
    // 例を挙げれば 無効な値(1.aaa), 矛盾する値(1024_i8), 存在しない値への参照など

    // 以下のいずれか1つ以上の状態も「悪い状態」に該当する
    //  - 悪い状態がときに起こるとは予想されないとき。
    //  - この時点以降、この悪い状態にないことを頼りにコードが書かれているとき。   
    //  - 使用している型にこの情報をコード化するいい手段がないとき。

    // 誰かが自分のコードを呼び出して予期せぬ値を渡してきたら、
    // 最善の選択肢は panic! して開発段階で修正できるよう 自分たちのコードに不具合があることをライブラリ使用者に通知することかもしれない
    // 同様に 自分の制御下にない外部コードを呼び出して修正しようのない無効な状態を返すときに panic! はしばしば適切

    // どんなにコードを正確に書いても起こると予想されるが、
    // 悪い状態に達したとき やはり panic!呼出するより Result を返すほうがより適切で
    // 例を挙げれば 不正なデータを渡されたパーサ(構文解析器), 訪問制限に引っかかったことを示唆するステータスを返すHTTPリクエスト など
    // そんな時は 呼出側が問題の処理方法を決定できるように Result を返してこの悪い状態を委譲して、 
    // 失敗が予想されることを示唆するべき。panic! を呼び出すことはこれらのケースでは最善策ではない
    // つまりヤバそうなエラーは panic! してそれ以外は Result を返せばいい : Result しようがなさそうだったらパニックしとけってことか

    // コードが値に対して処理を行う時 コードはまず値が合法であることを確認して 値が合法でなければパニックするべき
    // これは安全性上の理由によるもの。不正なデータの処理を試みると脆弱性を生みかねない
    // これが境界外へのメモリアクセスを試みたときに std が panic!を呼び出す主な理由となる
    // 現在のデータ構造に属しないメモリにアクセスを試みることは大きなセキュリティ問題

    // 関数にはしばしば契約が伴う。入力が特定の条件を満たすときのみ振る舞いが保証される/*#契約*/
    // 契約が侵されたときにパニックすることは道理が通っている
    // なぜなら契約侵害(必要な引数を無視しての関数の呼出など)は呼出側のバグを表していて 呼出側に明示的に処理してもらう必要のある種類のエラーではない故
    // 実際に呼出側が回復する合理的な手段はない。 呼出側のプログラマがコードを修正する必要がある
    // 関数の契約は 特に侵害がパニックを引き起こす際、関数の APIドキュメント内で説明されているはず(しなさい)

    // しかし全ての関数で大量のエラーチェックを行うことは冗長で煩わしい(わずらわしい:面倒だからやだ)
    // そんな贵樣に！幸運にも Rustの型システム(故にコンパイラが行う型精査)を使用して多くの検査を行ってもらうことが出来る
    // 関数の引数に特定の型があるならば コンパイラが合法な値があると既に確認している状態で コードのロジック(処理)に進むことができる
    // 例えば Option 以外の型がある場合 プログラムは何もないではなく何かあると想定する
    // そしたらコードは Some と None列挙子の2つの場合を処理する必要がなくなる
    // 確実に値があるという状況しかない故に。関数に何もないことを渡そうとしてくるコードは コンパイルが通りもしない故その場合を実行時に検査する必要はない
    // 別の例として u32 のような符号なし整数み負の数をぶち込むことなど

   // 検証のために独自の型を作る
    // Rustの型システムを使用して 合法な値があると確認するというアイディアを一歩先に進め、
    // 検証のために独自の型を作ることに目を向ける
    // 以前作った数当てゲーム(https://github.com/Rinrin0413/guessing-game)で、 
    // コードがユーザに1から100までの数字を推測するよう求めたことを思い出して(しなさい)
    // 秘密の数字と照合する前に ユーザの推測がそれらの値の範囲にあることを全く確認しなかった
    // 推測が正の数であることしか確認していなかった
    // この場合結果はそれほど悲惨なものではない
    // 大きすぎ, 小さすぎという出力は間違っていなかった
    // ユーザを合法な推測に導いて 範囲外の数字を推測したり文字を代わりに入力したりしたときに、
    // 各々で別の挙動をするようにすれば親切なアプリケーションとなるはず
    // これをする1つの方法として ただの u32 の代わりに i32 として推測をパースして、
    // 負の数になる可能性を許可して それから数字が範囲に収まっているというチェックを追加すること
    /*
    loop {
        //--略--
        let guess: i32 = match guess.trim().parse() { // 負の数も受け入れる
            Ok(num) => num,
            Err(_) => continue,
        };
        if guess < 1 || guess > 100 { // 範囲外なら
            println!("1 から 100 までの整数を推測して下さい"); // 範囲内で答えるように示唆して、
            continue; // loopをコンティニュ
        }
        match guess.cmp(&secret_number) {
        //--略--
    }
    */

    // 中央の if式が 値が範囲外かどうかをチェックして、
    // 範囲外ならユーザに問題を告知して continue を呼び出してループの次の繰り返しを始めて別の推測を求める

    // しかし 実はこれは理想的な解決策ではない
    // プログラムが1から100の範囲の値しか処理しないことが重要であり、
    // この要求がある関数の数が多くて チェックを全関数で行う事になった場合 面倒でパフォーマンスにも影響を及ぼす可能性がある
    // 代わりに新しい型を作って検証を関数内に閉じ込め、検証を全箇所で繰り返すのではなく その型のインスタンスを生成することができる
    // さすれば関数がその新しい型をシグニチャに用いて 受け取った値を自信を持って使用できるようになる
    // 以下に new関数が1から100までの値を受け取った時のみ Guess のインスタンスを生成する Guess型を定義する1つの方法を示した

    pub struct Guess { value: u32, }
    impl Guess { 
        // Guessインスタンスの new関連関数
        // ↓ Guess::new(value: u32) で呼び出す
        pub fn new(value: u32) -> Guess {
            if value < 1 || value > 100 {
                panic!("予想の値は1から100の範囲でなければならないが、{}でした.", value);
            }
            Guess { value } // 1~100ならばその値を保持するGuess型を返す
        }
        // Guessインスタンスの valueメソッド(メソッド記法)
        // ↓ <Guessのインスタンス>.value() で呼び出す
        pub fn value(&self) -> u32 { self.value } // self (つまり連結元)の Guessインスタンスの中身を u32 として返す
    }
    println!( "{}",  Guess::new(33).value() ); //< 33
                                               // new関数で33を持つGuessインスタンスを生成
                                               // この時1~100の範囲外の場合パニックする
                                               // value関数を繋げてu32に戻す
                                               // 33は範囲内なので無事33が出力される
    println!( "{}",  Guess::new(1024).value() ); //< thread 'main' panicked at '予想の値は1から100の範囲でなければならないが、1024でした.', --以下略--
                                                 // 1024は範囲内なのでパニック

    // まず value:u32 を持つ構造体Guess を定義している。ここに数値が保管される

    // それから Guess型に、Guess値のインスタンスを生成する new関連関数を実装
    // new関数は u32型の引数を取って その値を持つ Guess型を返すようになっている
    // 返す前に受け取った値が 1から100 の範囲であることを確かめる。範囲外だった場合 panic!呼出を行う
}