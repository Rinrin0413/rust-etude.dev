#![allow(unused)]
    // 全てのプログラミング言語には 概念の重複を効率的に扱う道具がある
    // Rust において そのような道具の1つがジェネリクス /*#ジェネリクス*/
    // ジェネリクスは具体型や他のプロパティの抽象的な代役となる
    // コード記述の際、コンパイル時にジェネリクスに何が入るかを知らずに ジェネリクスの振る舞いや他のジェネリクスとの関係を表現できる
    // 関数が未知の値の引数を取って同じ処理を複数の具体的な値に対してするのと同じく、
    // 具体的な型の代わりに何かジェネリックな(型に囚われない)型の引数を取ることができる
    // 実際 過去に Option<T>, Vec<T>, HashMap<K, V>, Result<T, E> などを使ってきた

    // 今回は 独自の型, 関数, メソッドをジェネリクスとともに定義する方法を学ぶ
    // まず関数を抽出して コードの重複を減らす方法を確認する
    // 次に同じテクニックを活用して 引数の型が異なる2つの関数からジェネリックな関数を生成する
    // また、ジェネリックな型を構造体や enum定義で使用する方法も説明する
    // それからトレイトを使ってジェネリックな方法で振る舞いを定義する方法を学ぶ
    // ジェネリックな型にトレイトを組み合わせて、
    // ジェネリックな型を単にあらゆる型に対してではなく 特定の振る舞いの特定の型のみに制限できる
    // 最後にライフタイムについて学ぶ
    // ライフタイムとは コンパイラに参照がお互いにどう関係しているかの情報を与える一種のジェネリクス
    // ライフタイムのおかげで コンパイラが参照が有効だと確認できて 多くの場面で値を借用できる
pub fn abstract_by_fun() {
  // 関数を抽出することで重複を取り除く
    // ジェネリクスの記法を学ぶ前に 関数を抽出してジェネリックな型を使わない重複の取り除きを見てみる
    // そして このテクニックを使ってジェネリックな関数を抽出することになる
    // 重複したコードを関数にまとめること気付けるのと同じく ジェネリクスを使用できる重複コードも自ずと分かって来るでしょう
    // 以下の様な リスト内の最大値を求める短いプログラムを考えてみる
}