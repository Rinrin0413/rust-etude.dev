#![allow(unused)]
    // 全てのプログラミング言語には 概念の重複を効率的に扱う道具がある
    // Rust において そのような道具の1つがジェネリクス /*#ジェネリクス*/
    // ジェネリクスは具体型や他のプロパティの抽象的な代役となる
    // コード記述の際、コンパイル時にジェネリクスに何が入るかを知らずに ジェネリクスの振る舞いや他のジェネリクスとの関係を表現できる
    // 関数が未知の値の引数を取って同じ処理を複数の具体的な値に対してするのと同じく、
    // 具体的な型の代わりに何かジェネリックな(型に囚われない)型の引数を取ることができる
    // 実際 過去に Option<T>, Vec<T>, HashMap<K, V>, Result<T, E> などを使ってきた

    // 今回は 独自の型, 関数, メソッドをジェネリクスとともに定義する方法を学ぶ
    // まず関数を抽出して コードの重複を減らす方法を確認する
    // 次に同じテクニックを活用して 引数の型が異なる2つの関数からジェネリックな関数を生成する
    // また、ジェネリックな型を構造体や enum定義で使用する方法も説明する
    // それからトレイトを使ってジェネリックな方法で振る舞いを定義する方法を学ぶ
    // ジェネリックな型にトレイトを組み合わせて、
    // ジェネリックな型を単にあらゆる型に対してではなく 特定の振る舞いの特定の型のみに制限できる
    // 最後にライフタイムについて学ぶ
    // ライフタイムとは コンパイラに参照がお互いにどう関係しているかの情報を与える一種のジェネリクス
    // ライフタイムのおかげで コンパイラが参照が有効だと確認できて 多くの場面で値を借用できる
pub fn abstract_by_fun() {
  // 関数を抽出することで重複を取り除く
    // ジェネリクスの記法を学ぶ前に 関数を抽出してジェネリックな型を使わない重複の取り除きを見てみる
    // そして このテクニックを使ってジェネリックな関数を抽出することになる
    // 重複したコードを関数にまとめること気付けるのと同じく ジェネリクスを使用できる重複コードも自ずと分かって来るでしょう
    // 以下の様な リスト内の最大値を求める短いプログラムを考えてみる
    let num_list = vec![34, 50, 25, 100, 65];
    let mut max = num_list[0];
    for n in num_list {
        if n > max { max = n; } // 現時点の max より n の方が大きかったら n に置換
    }                           // つまり常に max には走査してきた値の最大値となる
    println!("最大値: {}", max);

    // 整数のリストを変数num_list に格納して 変数max にリストの最初の数字を配置している
    // そしてリストの数字全部を走査して 走査されてきた n  が max に格納された数値よりも大きければ、
    // その変数の値を置き換える。リストの数値全てを走査した頃には max はリストの最大値を保持しているはず。今回は100になる
    // 2つの異なるリストから別々に最大値を取得するには 上記コードを複製して2箇所で同じロジック(機構)を使用できる
    let num_list_ii = vec![34, 50, 25, 100, 65];
    let mut max = num_list_ii[0];
    for n in num_list_ii {
        if n > max { max = n; }
    }
    println!("最大値II: {}", max);

    let num_list_iii = vec![102, 34, 6000, 89, 54, 2, 43, 8];
    let mut max = num_list_iii[0];
    for n in num_list_iii {
        if n > max { max = n; }
    }
    println!("最大値III: {}", max);
}